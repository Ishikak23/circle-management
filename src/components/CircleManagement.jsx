import React, { useEffect, useState } from "react";

// {label : autogenerated, color: colorPattern, id: }

const CircleManagement = () => {
  const colors = ["blue", "pink", "yellow", "green"];
  const [circleData, setCircleData] = useState([]);
  const [selectedCircle, setSelectCircle] = useState(new Set());
  const [undoStack, setUndoStack] = useState([]);
  const [redoStack, setRedoStack] = useState([]);
  const [filteredData, setFilteredData] = useState([]);

  const handleClick = () => {
    setUndoStack((prev) => [...prev, circleData]);
    setRedoStack([]);
    let newData;
    if (circleData.length === 0) {
      newData = {
        count: 0,
        color: colors[0],
        label: 1,
      };
    } else {
      const lastItem = circleData[circleData.length - 1];
      const lastColorIndex = colors.findIndex(
        (item) => item === lastItem.color
      );
      const newIndex = lastColorIndex < 3 ? lastColorIndex + 1 : 0;
      newData = {
        count: 0,
        color: colors[newIndex],
        label: lastItem.label + 1,
      };
    }
    setCircleData([...circleData, newData]);
  };

  useEffect(() => {
    const handleKeyDown = (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === "z") {
        e.preventDefault();
        handleUndo();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === "y") {
        e.preventDefault();
        handleRedo();
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  });

  const handleUndo = () => {
    if (undoStack.length === 0) return;
    const lastAction = undoStack[undoStack.length - 1];
    const undo = undoStack.slice(0, -1);
    setUndoStack(undo);
    setRedoStack((prev) => [...prev, circleData]);
    setCircleData(lastAction);
  };

  const handleRedo = () => {
    if (redoStack.length === 0) return;
    const nextAction = redoStack[redoStack.length - 1];
    const redo = redoStack.slice(0, -1);
    setUndoStack((prev) => [...prev, circleData]);
    setRedoStack(redo);
    setCircleData(nextAction);
  };

  const handleDelete = () => {
    setUndoStack((prev) => [...prev, circleData]);
    setRedoStack([]);
    setCircleData((prev) => {
      return prev.filter((item) => !selectedCircle.has(item.label));
    });
    setSelectCircle(new Set());
  };

  const handleCircleClick = (event) => (label) => {
    if (event.shiftKey) {
      setSelectCircle((prev) => {
        const newSet = new Set(prev);
        if (newSet.has(label)) {
          newSet.delete(label);
        } else {
          newSet.add(label);
        }
        return newSet;
      });
    } else {
      setUndoStack((prev) => [...prev, circleData]);
      setRedoStack([]);
      setCircleData((prev) => {
        return prev?.map((item) => {
          if (item.label === label) {
            return {
              ...item,
              count: item.count + 1,
            };
          }
          return item;
        });
      });
    }
  };

  const handleFilter = (e) => {
    if (e.target.value === "all") {
      setFilteredData([]);
    }
    const data = circleData.filter((item) => item.color === e.target.value);
    setFilteredData(data);
  };

  const showData = filteredData.length !== 0 ? filteredData : circleData;

  return (
    <div className="circle-container">
      <div className="circle-header">
        <select onChange={handleFilter} className="button">
          <option value={"all"}>All Color</option>
          {colors.map((item, index) => {
            return (
              <option key={index} value={item}>
                {item}
              </option>
            );
          })}
        </select>
        <button onClick={handleClick} className="button">
          Add
        </button>
        <button onClick={handleDelete} className="button">
          Remove Selected
        </button>
        {selectedCircle.size > 0 && <p>{selectedCircle.size} Selected Item</p>}
      </div>
      <div className="circle-body">
        {showData.map((circleItem, index) => {
          const color = circleItem.color;
          return (
            <div
              key={index}
              className={`circle ${color} ${
                selectedCircle.has(circleItem.label) ? "selected" : ""
              }`}
              onClick={(e) => handleCircleClick(e)(circleItem.label)}
            >
              {circleItem.label}&nbsp; count : {circleItem.count}
            </div>
          );
        })}
      </div>
    </div>
  );
};

export default CircleManagement;
