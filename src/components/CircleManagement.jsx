import React, { useEffect, useState } from "react";

// {label : autogenerated, color: colorPattern, id: }

const CircleManagement = () => {
  const colors = ["blue", "pink", "yellow", "green"];
  const [circleData, setCircleData] = useState([]);
  const [selectedCircle, setSelectCircle] = useState(new Set());
  const [undoStack, setUndoStack] = useState([]);
  const [redoStack, setRedoStack] = useState([]);

  const handleClick = () => {
    setUndoStack((prev) => [...prev, circleData]);
    setRedoStack([]);
    let newData;
    if (circleData.length === 0) {
      newData = {
        count: 0,
        color: colors[0],
        label: 1,
      };
    } else {
      const lastItem = circleData[circleData.length - 1];
      const lastColorIndex = colors.findIndex(
        (item) => item === lastItem.color
      );
      const newIndex = lastColorIndex < 3 ? lastColorIndex + 1 : 0;
      newData = {
        count: 0,
        color: colors[newIndex],
        label: lastItem.label + 1,
      };
    }
    setCircleData([...circleData, newData]);
  };

  useEffect(() => {
    const handleKeyDown = (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === "z") {
        e.preventDefault();
        handleUndo();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === "y") {
        e.preventDefault();
        handleRedo();
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  });

  const handleUndo = () => {
    if (undoStack.length === 0) return;
    const lastAction = undoStack[undoStack.length - 1];
    setUndoStack((prev) => prev.slice(0, prev.length - 1));
    setRedoStack((prev) => [...prev, circleData]);
    setCircleData(lastAction);
  };

  const handleRedo = () => {
    if (redoStack.length === 0) return;
    const nextAction = redoStack[redoStack.length - 1];
    setUndoStack((prev) => [...prev, circleData]);
    setRedoStack((prev) => prev.slice(0, prev.length - 1));
    setCircleData(nextAction);
  };

  const handleDelete = () => {
    setUndoStack((prev) => prev.push(circleData));
    setRedoStack([]);
    setCircleData((prev) => {
      return prev.filter((item) => !selectedCircle.has(item.label));
    });
    setSelectCircle(new Set());
  };

  const handleCircleClick = (event) => (label) => {
    if (event.shiftKey) {
      setSelectCircle((prev) => {
        const newSet = new Set(prev);
        if (newSet.has(label)) {
          newSet.delete(label);
        } else {
          newSet.add(label);
        }
        return newSet;
      });
    } else {
      setUndoStack((prev) => [...prev, circleData]);
      setRedoStack([]);
      setCircleData((prev) => {
        return prev?.map((item) => {
          if (item.label === label) {
            item.count = item.count + 1;
          }
          return item;
        });
      });
    }
  };

  return (
    <div className="circle-container">
      <div className="circle-header">
        <button onClick={handleClick}>Add</button>
        <button onClick={handleDelete}>Remove Selected</button>
      </div>
      <div className="circle-body">
        {circleData.map((circleItem, index) => {
          const color = circleItem.color;
          return (
            <div
              key={index}
              className={`circle ${color} ${
                selectedCircle.has(circleItem.label) ? "selected" : ""
              }`}
              onClick={(e) => handleCircleClick(e)(circleItem.label)}
            >
              {circleItem.label}&nbsp; count : {circleItem.count}
            </div>
          );
        })}
      </div>
    </div>
  );
};

export default CircleManagement;
